@using EnvironmentalEconomy.Models
@model IEnumerable<ResultDbModel>
@{
    /**/

    ViewData["Title"] = "Index";
    Layout = "~/Views/Shared/_IndexLayout.cshtml";
}
<style>

    /* Set the size of the div element that contains the map */
    #map {
        width: 100%; /* The width is the width of the web page */
        height: 650px; /* The height is 400 pixels */
    }
</style>

<head>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <script src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.3.1.min.js"></script>
</head>

<!--The div element for the map -->
<div id="map"></div>
<input id="txtSearch" class="controls searchbox searchbox-shadow
       noprint directions-button-shown searchbox-empty suggestions-shown" type="text" placeholder="Search Box">


<script>
    // The location of Danang
    //var dad = { lat: 16.061195, lng: 108.228185 };
    var map;
    var heatmap;
    var dad = { lat: 16.062034, lng: 108.236130 };
    var circle = null;
    var infowindow = null;

    function Scope(latitude, longitude, radius) {
        this.latitude = latitude;
        this.longitude = longitude;
        this.radius = radius;
    }

    function GetCoor(str, radius) {
        var len = str.length;
        str = str.slice(1, len - 1);
        str = str.split(", ");
        str[0] = parseFloat(str[0]);
        str[1] = parseFloat(str[1]);
        coo = new Scope(str[0], str[1], radius);
        return coo;
    }

    function initMap() {
        // The map, centered at Danang
        map = new google.maps.Map(
            document.getElementById('map'), { zoom: 15, center: dad });

        heatmap = new google.maps.visualization.HeatmapLayer({
            data: getPoints(),
            map: map,
            //gradient: getGradient()
        });

        map.addListener('click', function (e) {
            //placeMarkerAndPanTo(e.latLng, map);
            if (circle != null) {
                circle.setMap(null);
            }
            circle = new google.maps.Circle({
                strokeColor: '#ed370e',
                strokeOpacity: 0.6,
                strokeWeight: 2,
                fillColor: '#b6e552',
                fillOpacity: 0.35,
                map: map,
                center: e.latLng,
                radius: 300,
                editable: true
            });
            map.panTo(e.latLng);
            SendScope(circle);

            circle.addListener('radius_changed', function (e) {
                SendScope(circle);
            });

            circle.addListener('center_changed', function (e) {
                map.panTo(circle.getCenter());
                SendScope(circle);
            });

            circle.addListener('click', function () {
                SendScope(circle);
            })
        });

        var input = document.getElementById('txtSearch');
        var searchBox = new google.maps.places.SearchBox(input);
        map.controls[google.maps.ControlPosition.TOP_LEFT].push(input);

        // Bias the SearchBox results towards current map's viewport.
        map.addListener('bounds_changed', function () {
            searchBox.setBounds(map.getBounds());
        });

        // Listen for the event fired when the user selects a prediction and retrieve
        // more details for that place.
        searchBox.addListener('places_changed', function () {
            var places = searchBox.getPlaces();

            var coo = GetCoor(places.geometry.location.toString(), 0);
            console.log(coo);
            map.panTo(new google.maps.LatLng(coo.latitude, coo.longitude));
            circle = new google.maps.Circle({
                strokeColor: '#ed370e',
                strokeOpacity: 0.6,
                strokeWeight: 2,
                fillColor: '#b6e552',
                fillOpacity: 0.35,
                map: map,
                center: new google.maps.LatLng(coo.latitude, coo.longitude),
                radius: 300,
                editable: true
            });
            SendScope(circle);
            //map.fitBounds(bounds);
        });

        function SendScope(circle) {
            coo = GetCoor(circle.getCenter().toString(), circle.getRadius());
            var MeanTemp = 0;
            var MeanHumd = 0;
            var MeanQual = 0;
            var count = 0;
            @foreach (var item in Model)
            {
                foreach(var res in item.Results)
                {
                    <text>
            var dist = distance(coo.latitude, coo.longitude, @res.Latitude, @res.Longtitude);
            if (dist < coo.radius) {
                MeanTemp += @res.Temperature;
                MeanHumd += @res.Humidity;
                MeanQual += @res.AirQuality;
                count += 1;
            }
                    </text>
                }
            }

            MeanTemp /= count;
            MeanHumd /= count;
            MeanQual /= count;

            var str = '<div id="content">' +
                '<div id="siteNotice">' +
                '</div>' +
                '<h2 id="firstHeading" class="firstHeading">Description</h2>' +
                '<div id="bodyContent">' +
                '<p>Mean Tempurature: <b>' + MeanTemp + '</b></p>' +
                '<p>Mean Humidity: <b>' + MeanHumd + '</b></p>' +
                '<p>Mean Air Quality: <b>' + MeanQual + '</b></p>' +
                '</div>' +
                '<div align="center"><input type="button" class="btn btn-primary" value="View Details"/></div>' +
                '</div>';
            if (infowindow != null) {
                infowindow.setMap(null);
            }
            infowindow = new google.maps.InfoWindow({
                content: str,
                position: circle.getCenter()
            });
            infowindow.open(map);
        }
    }

    function placeMarkerAndPanTo(latLng, map) {
        var marker = new google.maps.Marker({
            position: latLng,
            map: map
        });
        map.panTo(latLng);
    }

    function getPoints() {
        var points = [];
        var offset = 100;
        @foreach (var item in Model)
        {
            foreach(var res in item.Results)
            {
                <text>points.push({
                    location: new google.maps.LatLng(@res.Latitude, @res.Longtitude),
                    weight: @res.AirQuality * 0.1
                    })</text>
            }
        }
        return points;
    }

    function getGradient() {
        return [
            'rgba(0, 255, 255, 0)',
            'rgba(0, 255, 255, 1)',
            'rgba(0, 191, 255, 1)',
            'rgba(0, 127, 255, 1)',
            'rgba(0, 63, 255, 1)',
            'rgba(0, 0, 255, 1)',
            'rgba(0, 0, 223, 1)',
            'rgba(0, 0, 191, 1)',
            'rgba(0, 0, 159, 1)',
            'rgba(0, 0, 127, 1)',
            'rgba(63, 0, 91, 1)',
            'rgba(127, 0, 63, 1)',
            'rgba(191, 0, 31, 1)',
            'rgba(255, 0, 0, 1)'
        ];
    }

    function distance(lat1, lon1, lat2, lon2) {
        var R = 6371; // km (change this constant to get miles)
        var dLat = (lat2 - lat1) * Math.PI / 180;
        var dLon = (lon2 - lon1) * Math.PI / 180;
        var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
            Math.sin(dLon / 2) * Math.sin(dLon / 2);
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        var d = R * c;
        return Math.round(d * 1000);
    }

</script>

<!--Load the API from the specified URL
* The async attribute allows the browser to render the page while the API loads
* The key parameter will contain your own API key (which is not needed for this tutorial)
* The callback parameter executes the initMap() function
-->

<script async defer
        src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDr5qwgemJp4LtodR8lvXg382V-cDFK3bY&callback=initMap&libraries=places,visualization">
</script>

